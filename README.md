# Java CSV File Combiner

## Overview

This project contains a Java solution for a programming exercise that involves combining data from two CSV files based on a common identifier in the first column. If a row in the first CSV file (`csv1`) has a matching ID in the first column of a row in the second CSV file (`csv2`), the data from the second file's row (excluding its ID column) is appended to the first file's row. The resulting combined rows are then written to an output CSV file.

## Problem Description

The core task is to implement the `combineFiles(File csv1, File csv2, File outputFile)` method within the provided Java class structure.

**Input:**

* `csv1`: The primary CSV file.
* `csv2`: The secondary CSV file to match against.

**Process:**

1.  Read both CSV files.
2.  For each row in `csv1`, check if its first column value (the ID) exists in the first column of any row in `csv2`.
3.  If a match is found:
    * Take the row from `csv1`.
    * Take the corresponding row from `csv2`.
    * Remove the first column (the ID) from the `csv2` row.
    * Concatenate the modified `csv2` row to the `csv1` row, separated by a comma.
    * Write this combined row to the `outputFile`.
4.  Rows from either file that do not have a matching ID in the other file are ignored and not included in the output.

**Output:**

* `outputFile`: A CSV file containing only the combined rows where matching IDs were found.

**Example:**

* **CSV 1:**
    ```csv
    0,A,B,C
    1,G,H,I
    2,M,N,O
    ```

* **CSV 2:**
    ```csv
    1,J,K,L
    3,Q,R,S
    0,D,E,F
    8,X,Y,Z
    ```

* **Output File:**
    ```csv
    0,A,B,C,D,E,F
    1,G,H,I,J,K,L
    ```

**Explanation:**

* Row with ID `0` in CSV 1 matches the row with ID `0` in CSV 2. The data `D,E,F` from CSV 2 is appended.
* Row with ID `1` in CSV 1 matches the row with ID `1` in CSV 2. The data `J,K,L` from CSV 2 is appended.
* Row with ID `2` in CSV 1 has no match in CSV 2.
* Rows with IDs `3` and `8` in CSV 2 have no match in CSV 1.
* Therefore, only the combined rows for IDs `0` and `1` are written to the output file.

## Files in the Repository

* `src/test/TestSolution.java`: Contains the main Java class, including the `combineFiles` method implementation and the `main` method to run the solution.
* `resources/1.csv`: Example input file 1.
* `resources/2.csv`: Example input file 2.
* `resources/my_output.csv`: The default output file generated by the program.

## Implementation Details (`combineFiles` Method)

The `combineFiles` method is designed to efficiently process potentially large CSV files.

**Thought Process & Design Choices:**

1.  **Efficiency for Lookups:** Reading the second CSV file (`csv2`) entirely into memory first allows for quick lookups. A `HashMap` (`remainderById`) is used to store the data from `csv2`, mapping each row's ID (first column) to the rest of its columns (concatenated as a single string). This provides near O(1) average-case time complexity for checking if an ID from `csv1` exists in `csv2`. This is significantly more efficient than repeatedly scanning `csv2` for each row in `csv1`, especially for large files.
2.  **Memory Consideration:** While reading `csv2` into memory is efficient for lookups, it assumes that `csv2` (specifically, the relevant parts of its rows) can fit into available memory. If `csv2` were extremely large, an alternative approach like external sorting or database indexing might be necessary. For this exercise, the Map-based approach is a common and effective solution.
3.  **File Handling:** Standard Java `BufferedReader` and `BufferedWriter` are used for efficient reading and writing of file content line by line. `FileReader` and `FileWriter` handle the file stream connections. Using `try-with-resources` ensures that file resources (readers and writers) are automatically closed, preventing resource leaks.
4.  **Data Parsing:** Each line read from the CSV files is split into columns using `line.split(",", -1)`. The `-1` limit ensures that trailing empty columns are preserved, which is important for correct CSV handling. The ID is extracted from the first part (`parts[0]`), and whitespace is trimmed.
5.  **String Manipulation:** For `csv2`, the columns *after* the first one are joined back together with commas using `String.join(",", Arrays.copyOfRange(parts, 1, parts.length))` to create the value stored in the `remainderById` map. When a match is found, simple string concatenation (`line + "," + match`) is used to create the output line.
6.  **Error Handling:** The method signature includes `throws IOException` to propagate potential file I/O errors up the call stack. The `main` method includes a `try-catch` block to handle these exceptions gracefully and print stack traces for debugging. Basic checks for blank lines or lines without an ID are included.

## How to Run

1.  **Compile:** Navigate to the `src` directory in your terminal and compile the Java file:
    ```bash
    javac test/TestSolution.java
    ```
    (Ensure you have a Java Development Kit (JDK) installed and configured).

2.  **Run:** From the `src` directory, run the compiled class:
    ```bash
    java test.TestSolution
    ```
    The program will:
    * Read `resources/1.csv` and `resources/2.csv`.
    * Perform the matching and concatenation logic.
    * Write the output to `resources/my_output.csv`.
    * Print status messages to the console.

